Android Architecture
29 September 2016

* 안드로이드 구조 시리즈

- Annotation Processing (어노테이션으로 코드 다이어트)
- RetroLambda with Java 8 + 약간의 자바 기본 문법, Gradle (Java 8 활용, 빌드)
- REST, Retrofit, Gson (http 통신)
- Realm, Stetho, Flux Architecture (데이터베이스와 데이터 흐름)
- MVP (Model View Presenter) Architecture + Repository, Service (from DDD)
- Dependency Injection with Dagger (OOP, Component, Maintainable)
- RxJava, Frodo, Strict Mode (고수준의 비동기 처리)
- Junit, Robolectric, Mockito, Hamcrest (테스트를 작성하는 것이 빠른길)

하루에 하나씩 총 8일
(내용이나 순서는 바뀔지도? 아마도 테스트 관련은 나중)

* 1. Annotation Processing

* 1. Annotation Processing

- @Annotation 이 녀석이 어노테이션

도대체 왜 써야하는가?

* 1. Annotation Processing

- Before ButterKnife (button 클릭시 action)

    @Override
    public void onCreate(Bundle savedInstanceState) {
        Button button = findViewById(R.id.button);
        button.setOnClickListener(new View.OnClickListener() {
            @Override
            public void onClick(View v) {
                this.buttonOnClick(v);
            }
        });
    }

    void buttonOnClick(View v) {
        // TODO action
    }

* 1. Annotation Processing

- After ButterKnife (button 클릭시 action)

    @OnClick(R.id.button)
    void buttonOnClick(View v) {
        // TODO action
    }

코드가 간결하고 읽기 쉬워짐

하지만 왜 지금까지 어노테이션을 제대로 사용하지 못했나?

* 1. Annotation Processing

- 일반적으로 서버사이드에서 어노테이션은 런타임에 리플렉션을 사용해서 구현됨

- 하지만 런타임 리플렉션은 모바일에서 성능 이슈가 있음

※ Reflection이란? 런타임에 class 조사하는 Java API (주로 GC 계열 언어에서 채택)

- 그래서 나온 것이 Annotation Processing Tool (줄여서 APT)

- 어노테이션을 DSL이라 생각하고 컴파일 타임에 코드를 생성하자

* 1. Annotation Processing

단점 :

- 빌드 타임 생생 코드라서 에러 발생시 처음에는 해맬 수 있음
- 빌드 타임이 조금 늘어남
- 해당 라이브러리에 맞는 문법을 익혀야함
- 라이브러리 문제 발생시 깃헙 이슈 정도는 찾아볼 수 있어야함
- 이슈를 직접 수정하여 PR까지 할 수 있다면 금상첨화

* 1. Annotation Processing

어노테이션 프로세싱에 해당하는 라이브러리들
반복적이고 귀찮은 코드 작성들을 어노테이션 한줄로 대체

- ButterKnife : 뷰 인젝션 라이브러리
- Lombok : hashCode(), toString(), constructor, getter, setter 등을 자동으로 생성
- Dart/Henson : 엑티비티 간에 Bundle을 넘겨주고 Extra를 받는 코드를 자동 생성
- Parceler : Bundle은 기본적으로 Primitive 타입만 넘겨 줄 수 있음, 만약 사용자 class 타입을 넘기려면 장황한 Parcelable interface를 implements 해야함. 이 Parcelable implements를 자동 생성
- PermissionsDispatcher : 퍼미션 코드도 어노테이션으로 자동 생성
- Dagger : 나중에 설명할 DI 코드를 어노테이션으로 자동 생성

* 1. Annotation Processing (Lombok)

* 1. Annotation Processing (Lombok)

- Before Lombok
- (constructor, equals, hashCode, getter, setter를 가지는 Level class를 작성)

    public class Level {
        private Integer levelId;    
        private String levelName;    
        private long minPoint;    
        private long maxPoint;

        public Level(Integer levelId, String levelName, long minPoint, long maxPoint) {
            this.levelId = levelId;
            this.levelName = levelName;
            this.minPoint = minPoint;
            this.maxPoint = maxPoint;
        }
        ...
    }

* 1. Annotation Processing (Lombok)

        ...
        public boolean equals(Object o) {
            if (o == this) return true;
            if (!(o instanceof Level)) return false;
            final LevelVO other = (Level) o;
            if (!other.canEqual((Object) this)) return false;
            final Object this$levelId = this.levelId;
            final Object other$levelId = other.levelId;
            if (this$levelId == null ? other$levelId != null : !this$levelId.equals(other$levelId)) return false;
            final Object this$levelName = this.levelName;
            final Object other$levelName = other.levelName;
            if (this$levelName == null ? other$levelName != null : !this$levelName.equals(other$levelName)) return false;
            if (this.minPoint != other.minPoint) return false;
            if (this.maxPoint != other.maxPoint) return false;
            return true;
        }
        ...

* 1. Annotation Processing (Lombok)
        ...
        public int hashCode() {
            final int PRIME = 59;
            int result = 1;
            final Object $levelId = this.levelId;
            result = result * PRIME + ($levelId == null ? 0 : $levelId.hashCode());
            final Object $levelName = this.levelName;
            result = result * PRIME + ($levelName == null ? 0 : $levelName.hashCode());
            final long $minPoint = this.minPoint;
            result = result * PRIME + (int) ($minPoint &amp;gt;&amp;gt;&amp;gt; 32 ^ $minPoint);
            final long $maxPoint = this.maxPoint;
            result = result * PRIME + (int) ($maxPoint &amp;gt;&amp;gt;&amp;gt; 32 ^ $maxPoint);
            return result;
        }    
        public boolean canEqual(Object other) {
            return other instanceof Level;
        }    
        public Integer getLevelId() {
            return this.levelId;
        }    
        ...

* 1. Annotation Processing (Lombok)
    {
        ...
        public String getLevelName() {
            return this.levelName;
        }
        public long getMinPoint() {
            return this.minPoint;
        }
        public long getMaxPoint() {
            return this.maxPoint;
        }
        public void setLevelName(String levelName) {
            this.levelName = levelName;
        }
        public void setMinPoint(long minPoint) {
            this.minPoint = minPoint;
        }
        public void setMaxPoint(long maxPoint) {
            this.maxPoint = maxPoint;
        }
    }

Android Studio가 자동 생성을 잘 지원하고는 있지만 매우 장황하고 읽기도 힘듬

* 1. Annotation Processing (Lombok)

- After Lombok
- (constructor, equals, hashCode, getter, setter를 가지는 Level class를 작성)
   
    @EqualsAndHashCode
    @AllArgsConstructor
    public class Level {
    
        @Getter    
        private Integer levelId;
    
        @Getter @Setter
        private String levelName;
    
        @Getter @Setter
        private long minPoint;
    
        @Getter @Setter
        private long maxPoint;   
    }

믿기지 않겠지만 앞의 코드와 정확히 같은 일을 하는 코드입니다.

* 1. Annotation Processing (Dart/Henson)

* 1. Annotation Processing (Dart/Henson)

- Before Dart/Henson (bundle로 ExampleActivity에 extra를 넘김)

    class ExampleActivity extends Activity {
        String extra1;
        int extra2;
        bool extra3;        
        User extra4; // User implements Parcelable

        @Override public void onCreate(Bundle savedInstanceState) {
            this.extra1 = getIntent().getStringExtra("extra1");
            this.extra2 = getIntent().getIntExtra("extra2", 0);
            this.extra3 = getIntent().getBooleanExtra("extra3", true);
            thix.extra4 = getIntent().getParcelableExtra("extra3");
        }
    }

    Bundle bundle = new Bundle();
    bundle.putString("extra1", "hello");
    bundle.putInt("extra2", 1);
    bundle.putBoolean("extra3", true);
    bundle.putParcelable("extra4", new User());    
    Intent intent = new Intent(this, NextActivity.class);
    intent.putExtras(bundle);
    startActivity(intent);   
    
* 1. Annotation Processing (Dart/Henson)

- After Dart/Henson (bundle로 ExampleActivity에 extra를 넘김)

    class ExampleActivity extends Activity {
        @InjectExtra String extra1;
        @InjectExtra int extra2;
        @InjectExtra bool extra3;
        @InjectExtra User extra4; // User implements Parcelable

        @Override public void onCreate(Bundle savedInstanceState) {
            Dart.inject(this);
        }
    }

    Intent intent = Henson.with(this).gotoExampleActivity()
                .extra1("hello").extra2(1)
                .extra3(true).extra4(new User())
                .build();
        
    startActivity(intent);

Dart : Extra를 자동으로 injection 해 줌
Henson : 어노테이션을 보고 메서드 체인 형태로 intent 생성 코드를 자동으로 생성해줌

* 1. Annotation Processing (Dart/Henson)

- Bonus : 만약 Dart 없이 Henson을 사용하고 싶다면?

    @HensonNavigable // HensonNavigable 어노테이션을 달고 컴파일을 한번 돌리면
    class ExampleActivity extends Activity {
        @Override public void onCreate(Bundle savedInstanceState) {
            ...
        }
    }

    // gotoExampleActivity 메서드가 생성
    Intent intent = Henson.with(this).gotoExampleActivity().build();        
    startActivity(intent);

- 하지만... Extra 없으면 그냥 이쪽이 나을지도

    Intent intent = new Intent(this, ExampleActivity.class);
    startActivity(intent);

* 1. Annotation Processing (Parceler)

* 1. Annotation Processing (Parceler)

- Bundle은 기본적으로 Primitive 타입만 넘겨 줄 수 있음
- 사용자 class 타입을 넘기려면 Parcelable interface를 implements 해야함
- Before Parceler (Level class를 Parcelable로 사용)

    public class Level implements Parcelable {

        private Integer levelId;
        private String levelName;
        private long minPoint;
        private long maxPoint;

        public Level(Parcel in) {
            levelId = in.readInt();
            levelName = in.readString();
            minPoint = in.readLong()
            maxPoint = in.readLong();
        }
        ...
    }

* 1. Annotation Processing (Parceler)
    {
        ...
        @Override
        public int describeContents() {
            return 0;
        }

        @Override
        public void writeToParcel(Parcel dest, int flags) {
            dest.writeInt(levelId);
            dest.writeString(levelName);
            dest.writeLong(minPoint);
            dest.writeLong(maxPoint);
        }
    }

    Bundle bundle = new Bundle();
    bundle.putParcelable("example", new Level());

직접 작성하기는 매우 귀찮은 Parcelable...

* 1. Annotation Processing (Parceler)

- After Parceler (Level class를 Parcelable로 사용)

    @Parcel
    public class Level {

        private Integer levelId;
        private String levelName;
        private long minPoint;
        private long maxPoint;
    }

    Bundle bundle = new Bundle();
    bundle.putParcelable("example", Parcels.wrap(new Level()));

Parceler가 소포를 대신 포장해 드립니다

* 질문 있으신가요?

.image qna.jpg

* 도움이 될 만한 링크

.link https://realm.io/kr/news/aw202-butterknife-certificate-pinning/ AW202: ButterKnife, Certificate Pinning 등
.link https://realm.io/kr/news/remember-android/ 리멤버 안드로이드 변천기
.link https://realm.io/news/360andev-chris-guzman-android-libraries-beginner/ android libraries beginner
라이브러리 링크
.link https://github.com/JakeWharton/butterknife ButterKnife
.link https://projectlombok.org/ Lombok
.link https://github.com/f2prateek/dart Dart/Henson
.link https://github.com/johncarl81/parceler Parceler
.link https://github.com/hotchemi/PermissionsDispatcher PermissionsDispatcher
.link http://google.github.io/dagger/ Dagger 2
